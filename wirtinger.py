from subprocess import check_output
from sage.misc.parser import Parser
p = Parser(make_var=var)

def get_relation(x):
    if x[0] == 'x':
        t, l, r = x[1]
        if l-r==1:
            return [r, t, -l, -t]
        else:
            return [t, l, -t, -r]
        
    if x[0] == 'v':
        vin, vout = x[1]
        return [v for v in vin] + [-v for v in vout]
        
def D(r, i, xs):
    x = xs[r[0]-1] if r[0] > 0 else (xs[-r[0]-1])**(-1)
    if len(r) == 1:
        if r[0] > 0:
            if r[0] == i:
                return 1
            else:
                return 0
        else:
            if -r[0] == i:
                return -x
            else:
                return 0
    else:
        return D([r[0]],i, xs)+ x*D(r[1:], i, xs)
    
def get_matrix(G):
    relations = list(map(get_relation, G))
    n_var = max([abs(x) for x in sum(relations, [])])
    xs = [var('x'+str(i)) for i in range(1, n_var+1)]
    
    l = [i for i in range(n_var)]
    
    def find(seg):
        if seg == l[seg]:
            return seg
        l[seg] = find(l[seg])
        return l[seg]

    def union(seg_i, seg_j):
        iloc = find(seg_i)
        jloc = find(seg_j)

        if iloc <= jloc:
            l[jloc] = iloc
        else:
            l[iloc] = jloc
        return 0
    
    for _, r in [rel for rel in G if rel[0] == 'x']:
        union(r[1]-1,r[2]-1)
    
    union_result = [find(i) for i in range(n_var)]
    
    n_edge = len(set(union_result))

    ts = {label:var('t'+str(i+1)) for i, label in enumerate(list(set(union_result))) }
    homomorphism = {x:ts[union_result[i]] for i, x in enumerate(xs)}
    
    print('found: '+ str(n_var)+' segments and '+str(n_edge)+' edges')
    
    print('the homomorphism from pi_1(X) into an abelian group generated by edges is:')
    print(homomorphism)
    
    M = [[0 for j in range(len(relations))] for i in range(n_var)]
    for i in range(n_var):
        for j in range(len(relations)):
            entry = D(relations[j], i+1, xs)
            M[i][j] = entry(homomorphism)
    return matrix(M)

def get_minors(M):
    mins = M.minors(M.ncols())
    i = 1

    while all([a == 0 for a in mins]) and i < M.ncols():
        mins = M.minors(M.ncols()-i)
        i += 1
    
    return [m for m in mins if m != 0]

def get_GCD(minors):
    return p.parse(check_output('wolframscript -c "PolynomialGCD['+', '.join([str(m) for m in minors])+ \
                        ']//Simplify//Expand"', shell = True).strip().decode("utf-8"))

def get_Alexander_poly(G):
    return get_GCD(get_minors(get_matrix(G)))